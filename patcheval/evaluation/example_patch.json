[
    {
        "cve": "CVE-2024-42005",
        "fix_patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 277e8a18ca..1f33132555 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -2444,18 +2444,37 @@ class Query(BaseExpression):\n         self.clear_deferred_loading()\n         self.clear_select_fields()\n         self.has_select_fields = True\n-\n+    \n         if fields:\n+            import re\n+            SAFE_LOOKUP_RE = re.compile(r'^[A-Za-z0-9_]+(?:__(?:[A-Za-z0-9_]+))*$')\n+    \n+            def _validate_lookup(lookup):\n+                if not isinstance(lookup, str) or not SAFE_LOOKUP_RE.match(lookup):\n+                    raise FieldError(\n+                        \"Invalid field lookup '%s' passed to values(); \"\n+                        \"only field names and lookups consisting of \"\n+                        \"ASCII letters, digits and underscores separated by \"\n+                        \"__ are allowed.\" % lookup\n+                    )\n+    \n             field_names = []\n             extra_names = []\n             annotation_names = []\n             if not self.extra and not self.annotations:\n                 # Shortcut - if there are no extra or annotations, then\n                 # the values() clause must be just field names.\n+                # Validate each field name to avoid SQL injection via\n+                # crafted field/JSON keys used as column aliases.\n+                for f in fields:\n+                    _validate_lookup(f)\n                 field_names = list(fields)\n             else:\n                 self.default_cols = False\n                 for f in fields:\n+                    # Validate each requested lookup component to ensure\n+                    # it can't be used to inject SQL into column aliases.\n+                    _validate_lookup(f)\n                     if f in self.extra_select:\n                         extra_names.append(f)\n                     elif f in self.annotation_select:\n@@ -2497,7 +2516,7 @@ class Query(BaseExpression):\n                     expr = self.annotations[expr.refs]\n                 group_by.append(expr)\n             self.group_by = tuple(group_by)\n-\n+    \n         self.values_select = tuple(field_names)\n         self.add_fields(field_names, True)\n \n\n"
    },
    {
        "cve": "CVE-2018-12976",
        "fix_patch": "diff --git a/gosrc/gosrc.go b/gosrc/gosrc.go\nindex 9a9e44b..e6db055 100644\n--- a/gosrc/gosrc.go\n+++ b/gosrc/gosrc.go\n@@ -376,9 +376,51 @@ func getDynamic(ctx context.Context, client *http.Client, importPath, etag strin\n \t\treturn nil, NotFoundError{Message: \"bad repo URL: \" + im.repo}\n \t}\n \tproto := im.repo[:i]\n+\t// Security: allow only safe repo schemes to avoid local file access and code execution via helpers.\n+\tswitch proto {\n+\tcase \"http\", \"https\", \"ssh\", \"git\":\n+\t\t// ok\n+\tdefault:\n+\t\treturn nil, NotFoundError{Message: \"unsupported repo scheme: \" + proto}\n+\t}\n \tclonePath := im.repo[i+len(\"://\"):]\n+\t// Security: reject dangerous characters and traversal in clonePath to prevent command injection and directory traversal.\n+\tif strings.ContainsAny(clonePath, \";\\n\\r`|&\\\\\") {\n+\t\treturn nil, NotFoundError{Message: \"unsafe characters in repo URL\"}\n+\t}\n+\tfor _, seg := range strings.Split(clonePath, \"/\") {\n+\t\tif seg == \"..\" {\n+\t\t\treturn nil, NotFoundError{Message: \"path traversal in repo URL\"}\n+\t\t}\n+\t}\n+\t// Security: allow only known VCS types.\n+\tswitch im.vcs {\n+\tcase \"git\", \"hg\", \"bzr\", \"svn\":\n+\t\t// ok\n+\tdefault:\n+\t\treturn nil, NotFoundError{Message: \"unsupported VCS: \" + im.vcs}\n+\t}\n+\n \trepo := strings.TrimSuffix(clonePath, \".\"+im.vcs)\n \tdirName := importPath[len(im.projectRoot):]\n+\t// Security: validate and normalize dirName to prevent traversal and invalid characters.\n+\tif strings.Contains(dirName, \"\\x00\") || strings.Contains(dirName, \"\\\\\") {\n+\t\treturn nil, NotFoundError{Message: \"invalid characters in import path\"}\n+\t}\n+\tif dirName != \"\" {\n+\t\tfor _, seg := range strings.Split(dirName, \"/\") {\n+\t\t\tif seg == \"..\" {\n+\t\t\t\treturn nil, NotFoundError{Message: \"path traversal in import path\"}\n+\t\t\t}\n+\t\t}\n+\t\t// Normalize to a canonical path rooted at \"/\".\n+\t\tcleaned := path.Clean(\"/\" + dirName)\n+\t\tif cleaned == \"/\" {\n+\t\t\tdirName = \"\"\n+\t\t} else {\n+\t\t\tdirName = cleaned\n+\t\t}\n+\t}\n \n \tresolvedPath := repo + dirName\n \tdir, err := getStatic(ctx, client, resolvedPath, etag)\n\n"
    }
]