{"cve":"CVE-2021-21384:0708", "fix_patch": ""}
{"cve":"CVE-2018-20834:0708", "fix_patch": ""}
{"cve":"CVE-2021-33420:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 0000000..5227fa9\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/index.js b/index.js\nindex b180286..c174029 100644\n--- a/index.js\n+++ b/index.js\n@@ -428,7 +428,11 @@ var builtInTransforms = [\n         },\n \n         fromSerializable: function (val) {\n-            return typeof GLOBAL[val.ctorName] === 'function' ? new GLOBAL[val.ctorName](val.arr) : val.arr;\n+            // Only allow predefined TypedArray constructors\n+            if (TYPED_ARRAY_CTORS.includes(val.ctorName) && typeof GLOBAL[val.ctorName] === 'function') {\n+                return new GLOBAL[val.ctorName](val.arr);\n+            }\n+            return val.arr;\n         }\n     },\n \n"}
{"cve":"CVE-2020-7764:0708", "fix_patch": ""}
{"cve":"CVE-2017-1001004:0708", "fix_patch": ""}
{"cve":"CVE-2017-1000189:0708", "fix_patch": ""}
{"cve":"CVE-2017-1001003:0708", "fix_patch": ""}
{"cve":"CVE-2016-1000232:0708", "fix_patch": ""}
{"cve":"CVE-2021-21321:0708", "fix_patch": ""}
{"cve":"CVE-2020-17479:0708", "fix_patch": ""}
{"cve":"CVE-2019-10792:0708", "fix_patch": ""}
{"cve":"CVE-2019-10795:0708", "fix_patch": ""}
{"cve":"CVE-2021-32796:0708", "fix_patch": ""}
{"cve":"CVE-2020-26226:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 0000000..5227fa9\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/lib/hide-sensitive.js b/lib/hide-sensitive.js\nindex 6098496..1b2a103 100644\n--- a/lib/hide-sensitive.js\n+++ b/lib/hide-sensitive.js\n@@ -11,7 +11,12 @@ module.exports = (env) => {\n     return /token|password|credential|secret|private/i.test(envVar) && size(env[envVar].trim()) >= SECRET_MIN_SIZE;\n   });\n \n-  const regexp = new RegExp(toReplace.map((envVar) => escapeRegExp(env[envVar])).join('|'), 'g');\n+  const patterns = toReplace.flatMap((envVar) => {\n+    const secret = env[envVar];\n+    return [escapeRegExp(secret), escapeRegExp(encodeURIComponent(secret))];\n+  });\n+  \n+  const regexp = new RegExp(patterns.join('|'), 'g');\n   return (output) =>\n     output && isString(output) && toReplace.length > 0 ? output.toString().replace(regexp, SECRET_REPLACEMENT) : output;\n };\n"}
{"cve":"CVE-2020-26237:0708", "fix_patch": ""}
{"cve":"CVE-2023-41039:0708", "fix_patch": ""}
{"cve":"CVE-2023-34457:0708", "fix_patch": ""}
{"cve":"CVE-2018-7753:0708", "fix_patch": ""}
{"cve":"CVE-2015-1326:0708", "fix_patch": ""}
{"cve":"CVE-2025-43859:0708", "fix_patch": ""}
{"cve":"CVE-2024-49750:0708", "fix_patch": ""}
{"cve":"CVE-2023-45809:0708", "fix_patch": ""}
{"cve":"CVE-2022-29217:0708", "fix_patch": ""}
{"cve":"CVE-2019-16789:0708", "fix_patch": ""}
{"cve":"CVE-2025-48374:0708", "fix_patch": ""}
{"cve":"CVE-2025-24882:0708", "fix_patch": ""}
{"cve":"CVE-2025-24806:0708", "fix_patch": ""}
{"cve":"CVE-2024-56362:0708", "fix_patch": ""}
{"cve":"CVE-2024-52309:0708", "fix_patch": ""}
{"cve":"CVE-2024-22199:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 0000000..5227fa9\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/django/django.go b/django/django.go\nindex 030fbe2..c6e92a8 100644\n--- a/django/django.go\n+++ b/django/django.go\n@@ -101,7 +101,7 @@ func (e *Engine) Load() error {\n \tpongoset := pongo2.NewSet(\"default\", pongoloader)\n \t// Set template settings\n \tpongoset.Globals.Update(e.Funcmap)\n-\tpongo2.SetAutoescape(false)\n+\tpongo2.SetAutoescape(true)\n \n \t// Loop trough each Directory and register template files\n \twalkFn := func(path string, info os.FileInfo, err error) error {\n"}
{"cve":"CVE-2023-52081:0708", "fix_patch": ""}
{"cve":"CVE-2023-45128:0708", "fix_patch": ""}
{"cve":"CVE-2023-40029:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 0000000000..5227fa9a7c\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/util/db/cluster.go b/util/db/cluster.go\nindex 9b405a9cac..bf5a89b507 100644\n--- a/util/db/cluster.go\n+++ b/util/db/cluster.go\n@@ -404,6 +404,8 @@ func SecretToCluster(s *apiv1.Secret) (*appv1.Cluster, error) {\n \tif s.Annotations != nil {\n \t\tannotations = collections.CopyStringMap(s.Annotations)\n \t\tdelete(annotations, common.AnnotationKeyManagedBy)\n+\t\t// Remove sensitive annotation to prevent exposure of secret data\n+\t\tdelete(annotations, \"kubectl.kubernetes.io/last-applied-configuration\")\n \t}\n \n \tcluster := appv1.Cluster{\n"}
{"cve":"CVE-2023-25168:0708", "fix_patch": ""}
{"cve":"CVE-2021-3583:0708", "fix_patch": ""}
{"cve":"CVE-2023-30172:0708", "fix_patch": ""}
{"cve":"CVE-2020-10691:0708", "fix_patch": ""}
{"cve":"CVE-2024-42005:0708", "fix_patch": ""}
{"cve":"CVE-2022-28346:0708", "fix_patch": ""}
{"cve":"CVE-2021-31542:0708", "fix_patch": ""}
{"cve":"CVE-2024-10220:0708", "fix_patch": ""}
{"cve":"CVE-2024-45043:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 0000000000..5227fa9a7c\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/receiver/awsfirehosereceiver/receiver.go b/receiver/awsfirehosereceiver/receiver.go\nindex 6211f61221..b88493d983 100644\n--- a/receiver/awsfirehosereceiver/receiver.go\n+++ b/receiver/awsfirehosereceiver/receiver.go\n@@ -233,8 +233,15 @@ func (fmr *firehoseReceiver) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n // validate checks the Firehose access key in the header against\n // the one passed into the Config\n func (fmr *firehoseReceiver) validate(r *http.Request) (int, error) {\n-\tif accessKey := r.Header.Get(headerFirehoseAccessKey); accessKey != \"\" && accessKey != string(fmr.config.AccessKey) {\n-\t\treturn http.StatusUnauthorized, errInvalidAccessKey\n+\t// When access key is configured, require it to be present and valid\n+\tif fmr.config.AccessKey != \"\" {\n+\t\taccessKey := r.Header.Get(headerFirehoseAccessKey)\n+\t\tif accessKey == \"\" {\n+\t\t\treturn http.StatusUnauthorized, errors.New(\"missing access key\")\n+\t\t}\n+\t\tif accessKey != string(fmr.config.AccessKey) {\n+\t\t\treturn http.StatusUnauthorized, errInvalidAccessKey\n+\t\t}\n \t}\n \treturn http.StatusAccepted, nil\n }\n"}
{"cve":"CVE-2021-21432:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 00000000..5227fa9a\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/source/github/authentication.go b/source/github/authentication.go\nindex 6d964e3a..3673fa35 100644\n--- a/source/github/authentication.go\n+++ b/source/github/authentication.go\n@@ -110,13 +110,36 @@ func (c *client) AuthenticateToken(r *http.Request) (*library.User, error) {\n \t\treturn nil, errors.New(\"no token provided\")\n \t}\n \n+\t// Validate token format before authorization\n+\tif !isValidTokenFormat(token) {\n+\t\treturn nil, errors.New(\"invalid token format\")\n+\t}\n+\n \tu, err := c.Authorize(token)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// Only return a valid user if authorization succeeds\n+\tif u == \"\" {\n+\t\treturn nil, errors.New(\"authorization failed\")\n+\t}\n+\n \treturn &library.User{\n \t\tName:  &u,\n \t\tToken: &token,\n \t}, nil\n }\n+\n+func isValidTokenFormat(token string) bool {\n+\t// Token should be a 40-character hex string (GitHub personal access token format)\n+\tif len(token) != 40 {\n+\t\treturn false\n+\t}\n+\tfor _, c := range token {\n+\t\tif !((c >= 'a' && c <= 'f') || (c >= '0' && c <= '9')) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n"}
{"cve":"CVE-2022-1992:0708", "fix_patch": ""}
{"cve":"CVE-2020-26294:0708", "fix_patch": ""}
{"cve":"CVE-2022-1986:0708", "fix_patch": ""}
{"cve":"CVE-2022-29188:0708", "fix_patch": ""}
{"cve":"CVE-2023-50726:0708", "fix_patch": ""}
{"cve":"CVE-2022-3920:0708", "fix_patch": ""}
{"cve":"CVE-2024-5138:0708", "fix_patch": "diff --git a/overlord/hookstate/ctlcmd/ctlcmd.go b/overlord/hookstate/ctlcmd/ctlcmd.go\nindex b663420a3f..206cf76aad 100644\n--- a/overlord/hookstate/ctlcmd/ctlcmd.go\n+++ b/overlord/hookstate/ctlcmd/ctlcmd.go\n@@ -188,6 +188,5 @@ func isAllowedToRun(uid uint32, args []string) bool {\n \t// note: commands still need valid context and snaps can only access own config.\n \treturn uid == 0 ||\n \t\tstrutil.ListContains(nonRootAllowed, args[0]) ||\n-\t\tstrutil.ListContains(args, \"-h\") ||\n-\t\tstrutil.ListContains(args, \"--help\")\n+\t\t(args[0] == \"help\" || args[0] == \"-h\" || args[0] == \"--help\")\n }\n"}
{"cve":"CVE-2024-27302:0708", "fix_patch": ""}
{"cve":"CVE-2021-21291:0708", "fix_patch": ""}
{"cve":"CVE-2021-43798:0708", "fix_patch": ""}
{"cve":"CVE-2020-11053:0708", "fix_patch": ""}
{"cve":"CVE-2020-4037:0708", "fix_patch": ""}
{"cve":"CVE-2024-25620:0708", "fix_patch": ""}
{"cve":"CVE-2022-2024:0708", "fix_patch": ""}
{"cve":"CVE-2022-39340:0708", "fix_patch": ""}
{"cve":"CVE-2018-12976:0708", "fix_patch": ""}
{"cve":"CVE-2024-54132:0708", "fix_patch": ""}
{"cve":"CVE-2024-6257:0708", "fix_patch": ""}
{"cve":"CVE-2020-15233:0708", "fix_patch": ""}
{"cve":"CVE-2021-36157:0708", "fix_patch": ""}
{"cve":"CVE-2020-29529:0708", "fix_patch": ""}
{"cve":"CVE-2024-43405:0708", "fix_patch": ""}
{"cve":"CVE-2023-33967:0708", "fix_patch": ""}
{"cve":"CVE-2024-27289:0708", "fix_patch": ""}
{"cve":"CVE-2023-30625:0708", "fix_patch": ""}
{"cve":"CVE-2022-23857:0708", "fix_patch": ""}
{"cve":"CVE-2019-19499:0708", "fix_patch": ""}
{"cve":"CVE-2022-1883:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 0000000..5227fa9\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/db/db.go b/db/db.go\nindex 88e5390..f3f67c9 100644\n--- a/db/db.go\n+++ b/db/db.go\n@@ -370,11 +370,13 @@ func (db *Database) SearchAttribute(query url.Values) (results []types.SearchRes\n \t}\n \n \tif v := query.Get(\"tf_version\"); string(v) != \"\" {\n-\t\twhere = append(where, fmt.Sprintf(\"states.tf_version LIKE '%s'\", fmt.Sprintf(\"%%%s%%\", v)))\n+\t\twhere = append(where, \"states.tf_version LIKE ?\")\n+\t\tparams = append(params, \"%\"+v+\"%\")\n \t}\n \n \tif v := query.Get(\"lineage_value\"); string(v) != \"\" {\n-\t\twhere = append(where, fmt.Sprintf(\"lineages.value LIKE '%s'\", fmt.Sprintf(\"%%%s%%\", v)))\n+\t\twhere = append(where, \"lineages.value LIKE ?\")\n+\t\tparams = append(params, \"%\"+v+\"%\")\n \t}\n \n \tif len(where) > 0 {\n"}
{"cve":"CVE-2024-52010:0708", "fix_patch": ""}
{"cve":"CVE-2023-41891:0708", "fix_patch": ""}
{"cve":"CVE-2022-23536:0708", "fix_patch": ""}
{"cve":"CVE-2024-24579:0708", "fix_patch": ""}
{"cve":"CVE-2020-4053:0708", "fix_patch": ""}
{"cve":"CVE-2025-24366:0708", "fix_patch": ""}
{"cve":"CVE-2022-4643:0708", "fix_patch": ""}
{"cve":"CVE-2023-26125:0708", "fix_patch": ""}
{"cve":"CVE-2023-24623:0708", "fix_patch": ""}
{"cve":"CVE-2022-24825:0708", "fix_patch": ""}
{"cve":"CVE-2021-32783:0708", "fix_patch": ""}
{"cve":"CVE-2021-3155:0708", "fix_patch": ""}
{"cve":"CVE-2025-29778:0708", "fix_patch": "diff --git a/pkg/cosign/cosign.go b/pkg/cosign/cosign.go\nindex 60ca41696..9831f2a81 100644\n--- a/pkg/cosign/cosign.go\n+++ b/pkg/cosign/cosign.go\n@@ -549,13 +549,45 @@ func matchSignatures(signatures []oci.Signature, subject, subjectRegExp, issuer,\n \t\t\treturn fmt.Errorf(\"certificate not found\")\n \t\t}\n \n-\t\tif err := matchCertificateData(cert, subject, subjectRegExp, issuer, issuerRegExp, extensions); err != nil {\n-\t\t\terrs = append(errs, err)\n-\t\t} else {\n-\t\t\t// only one signature certificate needs to match the required subject, issuer, and extensions\n-\t\t\treturn nil\n+\t\t// Check issuer regex pattern if provided\n+if issuerRegExp != \"\" {\n+\tregex, err := regexp.Compile(issuerRegExp)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"invalid regexp for issuer: %s : %w\", issuerRegExp, err)\n+\t}\n+\tif val := cosign.CertExtensions{Cert: cert}.GetIssuer(); !regex.MatchString(val) {\n+\t\terrs = append(errs, fmt.Errorf(\"issuer regex mismatch: expected %s, received %s\", issuerRegExp, val))\n+\t\tcontinue\n+\t}\n+}\n+\n+// Check subject regex pattern if provided\n+if subjectRegExp != \"\" {\n+\tregex, err := regexp.Compile(subjectRegExp)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"invalid regexp for subject: %s : %w\", subjectRegExp, err)\n+\t}\n+\tsans := cryptoutils.GetSubjectAlternateNames(cert)\n+\tmatched := false\n+\tfor _, s := range sans {\n+\t\tif regex.MatchString(s) {\n+\t\t\tmatched = true\n+\t\t\tbreak\n \t\t}\n \t}\n+\tif !matched {\n+\t\terrs = append(errs, fmt.Errorf(\"subject regex mismatch: expected %s, received %s\", subjectRegExp, strings.Join(sans, \", \")))\n+\t\tcontinue\n+\t}\n+}\n+\n+if err := matchCertificateData(cert, subject, \"\", issuer, \"\", extensions); err != nil {\n+\terrs = append(errs, err)\n+} else {\n+\t// only one signature certificate needs to match the required subject, issuer, and extensions\n+\treturn nil\n+}\n+\t}\n \n \tif len(errs) > 0 {\n \t\terr := multierr.Combine(errs...)\n"}
{"cve":"CVE-2022-24450:0708", "fix_patch": ""}
{"cve":"CVE-2021-29417:0708", "fix_patch": ""}
{"cve":"CVE-2021-41803:0708", "fix_patch": ""}
{"cve":"CVE-2024-45388:0708", "fix_patch": ""}
{"cve":"CVE-2023-25165:0708", "fix_patch": ""}
{"cve":"CVE-2021-22538:0708", "fix_patch": ""}
{"cve":"CVE-2023-23947:0708", "fix_patch": ""}
{"cve":"CVE-2023-25173:0708", "fix_patch": ""}
{"cve":"CVE-2022-36103:0708", "fix_patch": ""}
{"cve":"CVE-2023-22480:0708", "fix_patch": ""}
{"cve":"CVE-2022-36009:0708", "fix_patch": ""}
{"cve":"CVE-2021-32701:0708", "fix_patch": ""}
{"cve":"CVE-2021-21411:0708", "fix_patch": ""}
{"cve":"CVE-2022-35936:0708", "fix_patch": ""}
{"cve":"CVE-2022-23542:0708", "fix_patch": ""}
{"cve":"CVE-2024-1724:0708", "fix_patch": ""}
{"cve":"CVE-2023-22736:0708", "fix_patch": ""}
{"cve":"CVE-2020-8559:0708", "fix_patch": ""}
{"cve":"CVE-2023-5122:0708", "fix_patch": ""}
{"cve":"CVE-2022-46146:0708", "fix_patch": ""}
{"cve":"CVE-2022-31145:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 00000000..5227fa9a\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/auth/authzserver/resource_server.go b/auth/authzserver/resource_server.go\nindex 78e89529..ea61d034 100644\n--- a/auth/authzserver/resource_server.go\n+++ b/auth/authzserver/resource_server.go\n@@ -9,6 +9,7 @@ import (\n \t\"net/http\"\n \t\"net/url\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"k8s.io/apimachinery/pkg/util/sets\"\n \n@@ -38,6 +39,15 @@ func (r ResourceServer) ValidateAccessToken(ctx context.Context, expectedAudienc\n \t\treturn nil, fmt.Errorf(\"failed to unmarshal user info claim into UserInfo type. Error: %w\", err)\n \t}\n \n+\t// Validate token expiration\n+\texpTime, ok := claimsRaw[\"exp\"].(float64)\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"token missing expiration claim\")\n+\t}\n+\tif time.Now().After(time.Unix(int64(expTime), 0)) {\n+\t\treturn nil, fmt.Errorf(\"token has expired\")\n+\t}\n+\n \treturn verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), claimsRaw)\n }\n \n"}
{"cve":"CVE-2021-26921:0708", "fix_patch": ""}
{"cve":"CVE-2025-46331:0708", "fix_patch": ""}
{"cve":"CVE-2025-24976:0708", "fix_patch": ""}
{"cve":"CVE-2022-24738:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 00000000..5227fa9a\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/x/claims/keeper/ibc_callbacks.go b/x/claims/keeper/ibc_callbacks.go\nindex 5a27b235..38695315 100644\n--- a/x/claims/keeper/ibc_callbacks.go\n+++ b/x/claims/keeper/ibc_callbacks.go\n@@ -7,13 +7,25 @@ import (\n \tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n \ttransfertypes \"github.com/cosmos/ibc-go/v3/modules/apps/transfer/types\"\n \tchanneltypes \"github.com/cosmos/ibc-go/v3/modules/core/04-channel/types\"\n+\tporttypes \"github.com/cosmos/ibc-go/v3/modules/core/05-port/types\"\n \t\"github.com/cosmos/ibc-go/v3/modules/core/exported\"\n \n \t\"github.com/tharsis/evmos/v2/x/claims/types\"\n )\n \n+// verifyEnabledChannel checks if the channel is enabled for claims\n+func (k Keeper) verifyEnabledChannel(ctx sdk.Context, channelID string) bool {\n+\tparams := k.GetParams(ctx)\n+\tfor _, enabledChannel := range params.AuthorizedChannels {\n+\t\tif channelID == enabledChannel {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // OnRecvPacket performs an IBC receive callback. It performs a no-op if\n-// claims are inactive\n+// claims are inactive or the channel is not authorized\n func (k Keeper) OnRecvPacket(\n \tctx sdk.Context,\n \tpacket channeltypes.Packet,\n@@ -26,6 +38,16 @@ func (k Keeper) OnRecvPacket(\n \t\treturn ack\n \t}\n \n+\t// verify that the channel is enabled for claims\n+\tif !k.verifyEnabledChannel(ctx, packet.DestinationChannel) {\n+\t\terr := sdkerrors.Wrapf(\n+\t\t\ttypes.ErrInvalidChannel,\n+\t\t\t\"channel '%s' not authorized for claims\",\n+\t\t\tpacket.DestinationChannel,\n+\t\t)\n+\t\treturn channeltypes.NewErrorAcknowledgement(err.Error())\n+\t}\n+\n \t// unmarshal packet data to obtain the sender and recipient\n \tvar data transfertypes.FungibleTokenPacketData\n \tif err := transfertypes.ModuleCdc.UnmarshalJSON(packet.GetData(), &data); err != nil {\n@@ -107,7 +129,7 @@ func (k Keeper) OnRecvPacket(\n // OnAcknowledgementPacket claims the amount from the `ActionIBCTransfer` for\n // the sender of the IBC transfer.\n // The function performs a no-op if claims are disabled globally,\n-// acknowledgment failed, or if sender the sender has no claims record.\n+// the channel is not authorized, acknowledgment failed, or if sender the sender has no claims record.\n func (k Keeper) OnAcknowledgementPacket(\n \tctx sdk.Context,\n \tpacket channeltypes.Packet,\n@@ -120,6 +142,16 @@ func (k Keeper) OnAcknowledgementPacket(\n \t\treturn nil\n \t}\n \n+\t// verify that the channel is enabled for claims\n+\tif !k.verifyEnabledChannel(ctx, packet.SourceChannel) {\n+\t\terr := sdkerrors.Wrapf(\n+\t\t\ttypes.ErrInvalidChannel,\n+\t\t\t\"channel '%s' not authorized for claims\",\n+\t\t\tpacket.SourceChannel,\n+\t\t)\n+\t\treturn err\n+\t}\n+\n \tvar ack channeltypes.Acknowledgement\n \tif err := transfertypes.ModuleCdc.UnmarshalJSON(acknowledgement, &ack); err != nil {\n \t\treturn sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, \"cannot unmarshal ICS-20 transfer packet acknowledgement: %v\", err)\n"}
{"cve":"CVE-2022-31130:0708", "fix_patch": ""}
{"cve":"CVE-2022-23538:0708", "fix_patch": ""}
{"cve":"CVE-2024-47616:0708", "fix_patch": ""}
{"cve":"CVE-2024-24747:0708", "fix_patch": ""}
{"cve":"CVE-2024-39330:0708", "fix_patch": ""}
{"cve":"CVE-2021-35042:0708", "fix_patch": ""}
{"cve":"CVE-2021-33203:0708", "fix_patch": ""}
{"cve":"CVE-2022-28347:0708", "fix_patch": ""}
{"cve":"CVE-2017-7233:0708", "fix_patch": ""}
{"cve":"CVE-2021-3281:0708", "fix_patch": ""}
{"cve":"CVE-2018-14574:0708", "fix_patch": ""}
{"cve":"CVE-2021-45452:0708", "fix_patch": ""}
{"cve":"CVE-2015-8213:0708", "fix_patch": ""}
{"cve":"CVE-2022-21699:0708", "fix_patch": ""}
{"cve":"CVE-2023-34233:0708", "fix_patch": ""}
{"cve":"CVE-2022-21683:0708", "fix_patch": ""}
{"cve":"CVE-2024-23334:0708", "fix_patch": "diff --git a/vendor/llhttp b/vendor/llhttp\n--- a/vendor/llhttp\n+++ b/vendor/llhttp\n@@ -1 +1 @@\n-Subproject commit 9ab2afc85b2880d96a94d38afaee301c6a314049\n+Subproject commit 9ab2afc85b2880d96a94d38afaee301c6a314049-dirty\n"}
{"cve":"CVE-2022-37109:0708", "fix_patch": ""}
{"cve":"CVE-2023-49736:0708", "fix_patch": ""}
{"cve":"CVE-2024-39877:0708", "fix_patch": ""}
{"cve":"CVE-2023-33977:0708", "fix_patch": "diff --git a/tcms/kiwi_attachments/validators.py b/tcms/kiwi_attachments/validators.py\nindex 696a1439..6a64239e 100644\n--- a/tcms/kiwi_attachments/validators.py\n+++ b/tcms/kiwi_attachments/validators.py\n@@ -3,9 +3,16 @@ from django.utils.translation import gettext_lazy as _\n \n \n def deny_uploads_containing_script_tag(uploaded_file):\n-    for chunk in uploaded_file.chunks(2048):\n-        if chunk.lower().find(b\"<script\") > -1:\n-            raise ValidationError(_(\"File contains forbidden <script> tag\"))\n+    forbidden_patterns = [\n+        b\"<script\",    # HTML script tag\n+        b\"javascript:\"  # JavaScript URI\n+    ]\n+    \n+    # Read file in larger chunks for efficiency\n+    for chunk in uploaded_file.chunks(4096):\n+        lower_chunk = chunk.lower()\n+        if any(pattern in lower_chunk for pattern in forbidden_patterns):\n+            raise ValidationError(_(\"File contains forbidden JavaScript content\"))\n \n \n def deny_uploads_ending_in_dot_exe(uploaded_file):\n"}
{"cve":"CVE-2022-31506:0708", "fix_patch": ""}
{"cve":"CVE-2019-7539:0708", "fix_patch": ""}
{"cve":"CVE-2025-23042:0708", "fix_patch": ""}
{"cve":"CVE-2022-3298:0708", "fix_patch": ""}
{"cve":"CVE-2022-41672:0708", "fix_patch": ""}
{"cve":"CVE-2024-3571:0708", "fix_patch": ""}
{"cve":"CVE-2024-0243:0708", "fix_patch": ""}
{"cve":"CVE-2023-6831:0708", "fix_patch": ""}
{"cve":"CVE-2024-3848:0708", "fix_patch": ""}
{"cve":"CVE-2021-21354:0708", "fix_patch": ""}
{"cve":"CVE-2021-4315:0708", "fix_patch": ""}
{"cve":"CVE-2023-39631:0708", "fix_patch": ""}
{"cve":"CVE-2024-21542:0708", "fix_patch": ""}
{"cve":"CVE-2017-0360:0708", "fix_patch": ""}
{"cve":"CVE-2018-18074:0708", "fix_patch": ""}
{"cve":"CVE-2021-3987:0708", "fix_patch": ""}
{"cve":"CVE-2023-40267:0708", "fix_patch": ""}
{"cve":"CVE-2021-23727:0708", "fix_patch": ""}
{"cve":"CVE-2022-24065:0708", "fix_patch": ""}
{"cve":"CVE-2023-26145:0708", "fix_patch": ""}
{"cve":"CVE-2020-25459:0708", "fix_patch": ""}
{"cve":"CVE-2022-39286:0708", "fix_patch": ""}
{"cve":"CVE-2019-10856:0708", "fix_patch": ""}
{"cve":"CVE-2020-26215:0708", "fix_patch": ""}
{"cve":"CVE-2021-39163:0708", "fix_patch": ""}
{"cve":"CVE-2022-0577:0708", "fix_patch": ""}
{"cve":"CVE-2021-41125:0708", "fix_patch": ""}
{"cve":"CVE-2021-21360:0708", "fix_patch": ""}
{"cve":"CVE-2023-32303:0708", "fix_patch": ""}
{"cve":"CVE-2022-21712:0708", "fix_patch": ""}
{"cve":"CVE-2022-4724:0708", "fix_patch": ""}
{"cve":"CVE-2023-32309:0708", "fix_patch": ""}
{"cve":"CVE-2024-5823:0708", "fix_patch": ""}
{"cve":"CVE-2022-36087:0708", "fix_patch": ""}
{"cve":"CVE-2023-29159:0708", "fix_patch": ""}
{"cve":"CVE-2023-41040:0708", "fix_patch": ""}
{"cve":"CVE-2023-39660:0708", "fix_patch": ""}
{"cve":"CVE-2025-27154:0708", "fix_patch": ""}
{"cve":"CVE-2020-15278:0708", "fix_patch": "diff --git a/redbot/cogs/mod/kickban.py b/redbot/cogs/mod/kickban.py\nindex 88b9e053..c059dfb2 100644\n--- a/redbot/cogs/mod/kickban.py\n+++ b/redbot/cogs/mod/kickban.py\n@@ -484,6 +484,15 @@ class KickBanMixin(MixinMeta):\n                     )\n                     banned.append(user_id)\n                 else:\n+                    # Add hierarchy check to prevent privilege escalation\n+                    if guild.get_member(user_id):\n+                        member = guild.get_member(user_id)\n+                        if member.top_role >= author.top_role:\n+                            errors[user_id] = _(\"Cannot ban user {user_id} due to role hierarchy\").format(\n+                                user_id=user_id\n+                            )\n+                            continue\n+                            \n                     try:\n                         await guild.ban(user, reason=audit_reason, delete_message_days=days)\n                         log.info(\"{}({}) hackbanned {}\".format(author.name, author.id, user_id))\n"}
{"cve":"CVE-2024-48911:0708", "fix_patch": ""}
{"cve":"CVE-2020-28360:0708", "fix_patch": ""}
{"cve":"CVE-2017-16100:0708", "fix_patch": ""}
{"cve":"CVE-2021-23384:0708", "fix_patch": ""}
{"cve":"CVE-2024-53900:0708", "fix_patch": ""}
{"cve":"CVE-2022-35949:0708", "fix_patch": ""}
{"cve":"CVE-2022-0691:0708", "fix_patch": ""}
{"cve":"CVE-2019-10787:0708", "fix_patch": ""}
{"cve":"CVE-2020-7687:0708", "fix_patch": ""}
{"cve":"CVE-2018-16482:0708", "fix_patch": ""}
{"cve":"CVE-2021-23363:0708", "fix_patch": ""}
{"cve":"CVE-2019-10788:0708", "fix_patch": ""}
{"cve":"CVE-2020-7675:0708", "fix_patch": ""}
{"cve":"CVE-2019-15597:0708", "fix_patch": ""}
{"cve":"CVE-2020-7627:0708", "fix_patch": ""}
{"cve":"CVE-2020-7631:0708", "fix_patch": ""}
{"cve":"CVE-2020-7795:0708", "fix_patch": ""}
{"cve":"CVE-2018-3772:0708", "fix_patch": ""}
{"cve":"CVE-2020-7640:0708", "fix_patch": ""}
{"cve":"CVE-2017-16198:0708", "fix_patch": ""}
{"cve":"CVE-2020-7674:0708", "fix_patch": ""}
{"cve":"CVE-2021-23376:0708", "fix_patch": ""}
{"cve":"CVE-2020-28494:0708", "fix_patch": "diff --git a/image.js b/image.js\nindex 19631b27..14051fd3 100755\n--- a/image.js\n+++ b/image.js\n@@ -286,9 +286,16 @@ ImageProto.pipe = function(stream, type, options) {\n \n \t!self.builder.length && self.minify();\n \t!type && (type = self.outputType);\n+\t\n+\t// Security fix for CVE-2020-28494: Validate and sanitize input\n+\tif (typeof type !== 'string' || !/^[a-zA-Z0-9_]+$/.test(type)) {\n+\t\tthrow new Error('Invalid type parameter');\n+\t}\n \n \tF.stats.performance.open++;\n-\tvar cmd = spawn(CMD_CONVERT[self.cmdarg], self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-'), SPAWN_OPT);\n+\t// Use execFile instead of spawn with shell:true to prevent command injection\n+\tvar args = self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-');\n+\tvar cmd = execFile(CMD_CONVERT[self.cmdarg], args, {stdio: ['pipe', 'pipe', 'ignore']});\n \tcmd.stderr.on('data', stream.emit.bind(stream, 'error'));\n \tcmd.stdout.on('data', stream.emit.bind(stream, 'data'));\n \tcmd.stdout.on('end', stream.emit.bind(stream, 'end'));\n@@ -324,9 +331,16 @@ ImageProto.stream = function(type, writer) {\n \n \tif (!type)\n \t\ttype = self.outputType;\n+\t\n+\t// Security fix for CVE-2020-28494: Validate and sanitize input\n+\tif (typeof type !== 'string' || !/^[a-zA-Z0-9_]+$/.test(type)) {\n+\t\tthrow new Error('Invalid type parameter');\n+\t}\n \n \tF.stats.performance.open++;\n-\tvar cmd = spawn(CMD_CONVERT[self.cmdarg], self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-'), SPAWN_OPT);\n+\t// Use execFile instead of spawn with shell:true to prevent command injection\n+\tvar args = self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-');\n+\tvar cmd = execFile(CMD_CONVERT[self.cmdarg], args, {stdio: ['pipe', 'pipe', 'ignore']});\n \tif (self.currentStream) {\n \t\tif (self.currentStream instanceof Buffer)\n \t\t\tcmd.stdin.end(self.currentStream);\n"}
{"cve":"CVE-2020-7613:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 0000000..5227fa9\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/index.js b/index.js\nindex 7cdbddf..c9f0820 100755\n--- a/index.js\n+++ b/index.js\n@@ -484,15 +484,11 @@ class NodeClam {\n             return false;\n         }\n \n-        const version_cmds = {\n-            clamdscan: `${path} --version`,\n-            clamscan: `${path} --version`,\n-        };\n-\n         try {\n             await fs_access(path, fs.constants.R_OK);\n \n-            const {stdout} = await cp_exec(version_cmds[scanner]);\n+            // Use execFile instead of exec to prevent command injection\n+            const {stdout} = await cp_execfile(path, ['--version']);\n             if (stdout.toString().match(/ClamAV/) === null) {\n                 if (this.settings.debug_mode) console.log(`${this.debug_label}: Could not verify the ${scanner} binary.`);\n                 return false;\n"}
{"cve":"CVE-2020-28437:0708", "fix_patch": ""}
{"cve":"CVE-2017-16083:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 0000000..5227fa9\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/lib/router.js b/lib/router.js\nindex be232b9..ce04c3d 100644\n--- a/lib/router.js\n+++ b/lib/router.js\n@@ -4,7 +4,8 @@\n     indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n \n   Router = function(options) {\n-    var _bodyparser, _extend, _getSessionHandler, _isEmpty, _make_request_wrapper, _multipartparser, _parsePattern, _pushRoute, default_options, dispatch, domain, escaped_favicon, escaped_icons_png, escaped_pixel_gif, fs, http, mime_types, net, nsr_sessions, padString, path_tools, querystring, spawn, thousandSep, urlparse, uuid;\n+    var _bodyparser, _extend, _getSessionHandler, _isEmpty, _make_request_wrapper, _multipartparser, _parsePattern, _pushRoute, default_options, dispatch, domain, escaped_favicon, escaped_icons_png, escaped_pixel_gif, fs, http, mime_types, net, nsr_sessions, padString, path_tools, querystring, spawn, thousandSep, urlparse, uuid, path;\n+    path = require('path');\n     if (options == null) {\n       options = {};\n     }\n@@ -729,8 +730,15 @@\n       any: []\n     };\n     dispatch[\"static\"] = function(pathname, req, res) {\n-      var full_path;\n-      full_path = \"\" + dispatch.static_route + (unescape(pathname));\n+      // Security fix: Prevent directory traversal attacks\n+      const normalizedPath = path.normalize(unescape(pathname)).replace(/^(\\/\\.\\.)+/, '');\n+      const full_path = path.join(dispatch.static_route, normalizedPath);\n+      \n+      // Ensure the path doesn't escape the static root\n+      if (!full_path.startsWith(path.resolve(dispatch.static_route))) {\n+        return dispatch._403(null, res, pathname);\n+      }\n+      \n       return fs.exists(full_path, function(exists) {\n         var e, error;\n         if (exists) {\n"}
{"cve":"CVE-2016-10548:0708", "fix_patch": ""}
{"cve":"CVE-2018-3733:0708", "fix_patch": ""}
{"cve":"CVE-2020-7781:0708", "fix_patch": ""}
{"cve":"CVE-2020-15084:0708", "fix_patch": ""}
{"cve":"CVE-2022-2421:0708", "fix_patch": ""}
{"cve":"CVE-2022-29822:0708", "fix_patch": ""}
{"cve":"CVE-2023-28155:0708", "fix_patch": ""}
{"cve":"CVE-2022-2900:0708", "fix_patch": ""}
{"cve":"CVE-2018-3778:0708", "fix_patch": ""}
{"cve":"CVE-2022-0686:0708", "fix_patch": ""}
{"cve":"CVE-2024-30260:0708", "fix_patch": ""}
{"cve":"CVE-2025-23221:0708", "fix_patch": ""}
{"cve":"CVE-2022-0512:0708", "fix_patch": ""}
{"cve":"CVE-2022-0639:0708", "fix_patch": ""}
{"cve":"CVE-2021-23387:0708", "fix_patch": ""}
{"cve":"CVE-2018-3734:0708", "fix_patch": ""}
{"cve":"CVE-2020-8132:0708", "fix_patch": ""}
{"cve":"CVE-2018-3785:0708", "fix_patch": ""}
{"cve":"CVE-2017-16042:0708", "fix_patch": ""}
{"cve":"CVE-2022-24794:0708", "fix_patch": ""}
{"cve":"CVE-2022-0436:0708", "fix_patch": ""}
{"cve":"CVE-2021-32803:0708", "fix_patch": ""}
{"cve":"CVE-2022-0235:0708", "fix_patch": ""}
{"cve":"CVE-2024-29041:0708", "fix_patch": ""}
{"cve":"CVE-2021-3664:0708", "fix_patch": ""}
{"cve":"CVE-2022-0155:0708", "fix_patch": ""}
{"cve":"CVE-2021-46561:0708", "fix_patch": ""}
{"cve":"CVE-2022-0722:0708", "fix_patch": ""}
{"cve":"CVE-2020-7649:0708", "fix_patch": ""}
{"cve":"CVE-2020-26299:0708", "fix_patch": ""}
{"cve":"CVE-2021-37712:0708", "fix_patch": ""}
{"cve":"CVE-2021-37713:0708", "fix_patch": ""}
{"cve":"CVE-2021-32804:0708", "fix_patch": ""}
{"cve":"CVE-2017-16025:0708", "fix_patch": ""}
{"cve":"CVE-2021-41246:0708", "fix_patch": ""}
{"cve":"CVE-2015-3295:0708", "fix_patch": "diff --git a/.claude/settings.json b/.claude/settings.json\nnew file mode 100644\nindex 0000000..5227fa9\n--- /dev/null\n+++ b/.claude/settings.json\n@@ -0,0 +1,18 @@\n+{\n+  \"permissions\": {\n+    \"allow\": [\n+      \"Bash(*)\",\n+      \"text_editor(*)\",\n+      \"Read(*)\",\n+      \"Grep(*)\",\n+      \"Web Fetch(*)\",\n+      \"Todo(*)\",\n+      \"Memory(*)\"\n+    ],\n+    \"deny\": []\n+  },\n+  \"env\": {\n+    \"CLAUDE_CODE_AUTO_CONNECT_IDE\": \"false\",\n+    \"DISABLE_INTERLEAVED_THINKING\": \"true\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/lib/index.js b/lib/index.js\nindex abc1525..8743ba4 100644\n--- a/lib/index.js\n+++ b/lib/index.js\n@@ -21,7 +21,7 @@ var config = {\n };\n \n \n-var BAD_PROTOCOLS    = [ 'vbscript', 'javascript', 'file' ];\n+var BAD_PROTOCOLS    = [ 'vbscript', 'javascript', 'file', 'data' ];\n \n function validateLink(url) {\n   // url should be normalized at this point, and existing entities are decoded\n"}
